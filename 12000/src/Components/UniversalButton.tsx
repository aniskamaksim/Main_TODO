import React, {ButtonHTMLAttributes, DetailedHTMLProps} from 'react';
import Button from "@mui/material/Button";

type DefaultButtonPropsType = DetailedHTMLProps<ButtonHTMLAttributes<HTMLButtonElement>,
    HTMLButtonElement>

type ButtonsPropsType = DefaultButtonPropsType & {
    callBack: () => void
    disabled: boolean
    classVariant: "outlined" | "text" | "contained"
}

export const UniversalButton: React.FC<ButtonsPropsType> = (
    {callBack, disabled, classVariant, ...props}) => {

    // const callBackHandler = () => {
    //     callBack
    // }


    return (
        <div>
            <Button
                variant={classVariant}
                onClick={callBack}
                disabled={disabled}
                size={"medium"}
            >{props.name}
            </Button>
        </div>
    );
};

/* Все просто, следи за руками:
1. У кнопки стопятьсот миллионов аттрибутов и прописанных типов в Defaultвот этом всем
1.1. Они есть по умолчанию и передавать их без надобности нет смысла - их просто можно вызвать на кнопке в отрисовке
1.2. Смотри, например, name в ButtonS а теперь посмотри в UniversalButton. Понял?

2. то есть в пропсы этой кнопки руками прописывать нужно ну например какой-то атрибут, которого нет в дефолтбаттонпроспстайп
2.1 а так же, что чаще - пропсами нужно прописывать вот эти универсальные условия, которые будут выполняться в отрисовке,
превращая Универсальную кнопку в уникальную.
Вот смотри. Смотри внимательно!
App отрисовывает скрин и баттонс.
В баттонс пропсами передаётся то, что необходимо, чтобы они отрисовались
В баттонс отрисовывается УниверсалБаттон 2 раза. В ней нет онклика - онклик в универсалбаттоне.
Прописывая onClick  универсалбаттоне (а это пропс по умолчанию) ты пишешь, что онклик для всех кнопок будет!
Да, все кнопки по нажатию будут что-то делать. Теперь что они будут делать? Правильно: вызывать функцию. Какую?
А вот тут у всех по-разному. Поэтому нужно прописать, что по онКлику будет вызываться функция:
в пропс callBack()=> в onClick={props.callBack} или через функцию-стрелочника название этой функции (смотри выше)
3. Теперь самое невкусное. Смена классов по условию.
    3.1 Начинаешь с того, что прописываешь условие. Где? Да, в самом деле где?
    3.2. Условие включает в себя: если число достигло какого-то значения или больше  или меньше кокого-то ЗНАЧЕНИЯ.
    ЗНАЧЕНИЯ! Значит, пишем там, где рисуем эти кнопки - там есть в пропсах min и max Values
    пишешь условие - если то то если блаблабла
    Дальше. Написал. Куда всунуть?
    Ну надо всунуть в условия для кнопки. Пишешь название условия, присваиваешь переменную.
    переходишь в общую кнопку. Там надо это типизировать и прописать какие типы туда могут прийти.
    В самой универсальной кнопке выбираешь variant (это из mui аргумент на задание стиля кнопочке) и присваиваешь пропс.
    Profit ёпта!


*/